#!/usr/bin/env node
"use strict";
var __importDefault =
  (this && this.__importDefault) ||
  function (mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const path_1 = __importDefault(require("path"));
const discord_js_1 = __importDefault(require("discord.js"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const prompts_1 = __importDefault(require("prompts"));
const validate_npm_package_name_1 = __importDefault(
  require("validate-npm-package-name")
);
const appDirectory = path_1.default.join(__dirname, "../app");
const appPackage = require(path_1.default.resolve(
  path_1.default.join(appDirectory, "package.json")
));
const utilityPackage = require(path_1.default.join(
  __dirname,
  "../package.json"
));
const utilityNameAndVersion = `${utilityPackage.name} v${utilityPackage.version}`;
const fileDirectlyRun = require.main === module;
const [, , ...args] = process.argv;
class App {
  constructor(name, token) {
    this.name = name || appPackage.name;
    this.token = token || "DISCORD_BOT_TOKEN_PLACEHOLDER";
    this.directory = path_1.default.resolve(this.name);
    this.questions = [
      {
        type: "text",
        name: "name",
        initial: appPackage.name,
        validate: (name) => {
          const {
            validForNewPackages,
            errors,
            warnings,
          } = validate_npm_package_name_1.default(name);
          return (
            // @ts-expect-error
            validForNewPackages || `Error: ${(errors || warnings).join(", ")}.`
          );
        },
        message: "Application name?",
      },
      {
        type: "password",
        name: "token",
        initial: "DISCORD_BOT_TOKEN_PLACEHOLDER",
        message: "Discord bot token?",
      },
    ];
    this.updateQuestion = [
      {
        type: "confirm",
        name: "update",
        message: `Directory '${this.directory}' already exists. Do you want to update it?`,
      },
    ];
    this.updateSteps = [
      {
        message: `Updating core files in '${this.name}'...`,
        action: () => {
          fs_extra_1.default.copySync(
            `${appDirectory}/src/core`,
            `${this.directory}/src/core`
          );
          fs_extra_1.default.copySync(
            `${appDirectory}/src/index.js`,
            `${this.directory}/src/index.js`
          );
        },
      },
    ];
    this.cleanInstallSteps = [
      {
        message: `Creating directory '${this.name}'...`,
        action: () => fs_extra_1.default.mkdirSync(this.directory),
      },
      {
        message: "Creating boilerplate...",
        action: () => {
          fs_extra_1.default.copySync(appDirectory, this.directory);
          const gitIgnore = "node_modules/\ntoken.json\n";
          fs_extra_1.default.writeFileSync(
            path_1.default.join(this.directory, ".gitignore"),
            gitIgnore
          );
        },
      },
      {
        message: "Updating package.json...",
        action: () => {
          const description = `Generated by ${utilityNameAndVersion}.`;
          const newPackage = { ...appPackage, name: this.name, description };
          fs_extra_1.default.writeFileSync(
            path_1.default.join(this.directory, "package.json"),
            `${JSON.stringify(newPackage, null, 2)}\n`
          );
        },
      },
      {
        message: "Writing token.json...",
        action: () => {
          const newToken = { token: this.token };
          fs_extra_1.default.writeFileSync(
            path_1.default.join(this.directory, "token.json"),
            `${JSON.stringify(newToken, null, 2)}\n`
          );
        },
      },
      {
        message: "Installing modules...",
        action: () => {
          process.chdir(this.directory);
          child_process_1.execSync("npm i --loglevel=error");
        },
      },
    ];
    this.isDryRun = args[0] === "--dry-run";
    this.appStatus = { status: undefined };
  }
  async build() {
    try {
      console.log(
        `This utility will walk you through creating a ${utilityPackage.name} application.\n\nPress ENTER to use the default.\nPress ^C at any time to quit.\n\n${utilityNameAndVersion}\n`
      );
      if (fileDirectlyRun) {
        const promptAnswers = await prompts_1.default(this.questions);
        if (Object.entries(promptAnswers).length < 2) {
          console.log("\nQuitting...\n");
          process.exit(0);
        }
        this.name = promptAnswers.name;
        this.token = promptAnswers.token;
        console.log();
      }
      const isUpdate = this.verifyCreation();
      if (isUpdate) {
        return await this.update();
      }
      this.cleanInstallSteps.forEach(({ message, action }) => {
        console.log(message);
        if (!this.isDryRun) {
          action();
        }
      });
      if (!isUpdate) {
        console.log();
        console.log("Generating bot invite link...");
        const client = new discord_js_1.default.Client();
        await client
          .login(this.token)
          .then(() =>
            console.log(
              `Invite your bot: https://discordapp.com/oauth2/authorize?scope=bot&client_id=${client.user.id}`
            )
          )
          .catch(() =>
            console.warn(
              "Bot invite link was not generated due to the given bot token being invalid."
            )
          );
        console.log();
      }
      console.log(
        `Done!\n\nStart by running:\n\t$ cd ${this.name}/\n\t$ npm start`
      );
      this.appStatus = { status: "created" };
      return this.appStatus;
    } catch (e) {
      console.log("Error!\n");
      console.error(e);
      console.log();
      this.appStatus = { status: "error" };
      return this.appStatus;
    }
  }
  async update() {
    try {
      if (fileDirectlyRun) {
        const updatePromptAnswer = await prompts_1.default(this.updateQuestion);
        console.log();
        if (!updatePromptAnswer.update) {
          console.log("\nQuitting...\n");
          process.exit(0);
        }
      }
      this.updateSteps.forEach(({ message, action }) => {
        console.log(message);
        if (!this.isDryRun) {
          action();
        }
      });
      console.log(
        `Done!\n\nStart by running:\n\t$ cd ${this.name}/\n\t$ npm start`
      );
      this.appStatus = { status: "updated" };
      return this.appStatus;
    } catch (e) {
      console.log("Error!\n");
      console.error(e);
      console.log();
      this.appStatus = { status: "error" };
      return this.appStatus;
    }
  }
  verifyCreation() {
    return fs_extra_1.default.existsSync(this.directory);
  }
}
exports.default = App;
if (fileDirectlyRun) {
  new App().build();
}
